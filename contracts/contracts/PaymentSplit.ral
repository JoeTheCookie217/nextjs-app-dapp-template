// no constructor (check on parameters)
// unknnown size array

Contract PaymentSplit(
    numPayees: U256,
    mut numPayeesRegistered: U256,
    mut totalShares: U256,
    mut totalReleased: U256,
    mut balance: U256
) {

    mapping[Address, U256] sharesMap
    mapping[Address, U256] releasedMap

    event PayeeAdded(account: Address,  shares: U256)
    event PaymentReleased(to: Address,  amount: U256)
    event PaymentReceived(from: Address,  amount: U256)

    enum ErrorCodes {
        // InvalidPayee = 0
        InvalidShares = 1
        AccountHasShares = 2
        AccountHasNoShares = 3
        AccountIsNotDuePayment = 4
        InvalidSetup = 5
    }

    // address[] public payees

    @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false,assetsInContract = true)
    pub fn receive(amount: U256) -> () {
        assert!(numPayees > 0, ErrorCodes.InvalidSetup)
        assert!(numPayeesRegistered == numPayees, ErrorCodes.InvalidSetup)
        balance = balance + amount
        transferTokenToSelf!(callerAddress!(), ALPH, amount)
        emit PaymentReceived(callerAddress!(), dustAmount!())
    }

    @using(checkExternalCaller = false)
    pub fn addPayee(account: Address, shares: U256) -> () {
        addPayeeInternal(account, shares)
    }

    @using(updateFields = true)
    fn addPayeeInternal(account: Address, shares: U256) -> () {
        // assert!(account != new Address(""), ErrorCodes.InvalidPayee)
        assert!(shares > 0, ErrorCodes.InvalidShares)
        assert!(sharesMap[account] == 0, ErrorCodes.AccountHasShares)

        // payees.push(account)
        sharesMap[account] = shares
        totalShares = totalShares + shares
        numPayeesRegistered = numPayeesRegistered + 1
        emit PayeeAdded(account, shares)
    }

    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn release(account: Address) -> () {
        assert!(sharesMap[account] > 0, ErrorCodes.AccountHasNoShares)
        let payment = releasable(account)
        assert!(payment != 0, ErrorCodes.AccountIsNotDuePayment)
        totalReleased = totalReleased + payment
        releasedMap[account] = releasedMap[account] + payment
        transferTokenFromSelf!(account, ALPH, payment)
        balance = balance - payment
        // account.transfer(payment)
        emit PaymentReleased(account, payment)
    }


    @using(checkExternalCaller = false)
    pub fn releasable(account: Address)  -> (U256) {
        // let totalReceived = address(this).balance + totalReleased
        let totalReceived = dustAmount!()
        return pendingPayment(account, totalReceived, releasedMap[account])
    }

    pub fn pendingPayment(
        account: Address,
         totalReceived:  U256,
         alreadyReleased:  U256
    ) -> (U256) {
        return (totalReceived * sharesMap[account]) / totalShares - alreadyReleased
    }
}