Contract PaymentSplit(
    // numPayees: U256,
    mut totalShares: U256,
    mut totalReleased: U256,
    mut balance: U256
) {

    mapping[Address, U256] sharesMap
    mapping[Address, U256] releasedMap

    event PayeeAdded(account: Address,  shares: U256)
    event PaymentReleased(to: Address,  amount: U256)
    event PaymentReceived(from: Address,  amount: U256)

    enum ErrorCodes {
        // InvalidPayee = 0
        InvalidShares = 1
        AccountHasShares = 2
        AccountHasNoShares = 3
        AccountIsNotDuePayment = 4
    }

    // let mut totalShares: U256 
    // let mut totalReleased: U256 
    // address[] public payees

    // constructor(address[] memory _payees, U256[] memory _shares) payable {
    //     assert!(_payees.length == _shares.length, "PaymentSplitter: payees and shares length mismatch")
    //     assert!(_payees.length > 0, "PaymentSplitter: no payees")
    //     for (U256 i = 0 i < _payees.length i++) {
    //         _addPayee(_payees[i], _shares[i])
    //     }
    // }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn receive() -> () {
        balance = dustAmount!()
        emit PaymentReceived(callerAddress!(), dustAmount!())
    }

    @using(checkExternalCaller = false)
    pub fn addPayee(account: Address, shares: U256) -> () {
        addPayeeInternal(account, shares)
    }

    @using(updateFields = true)
    fn addPayeeInternal(account: Address, shares: U256) -> () {
        // assert!(account != new Address(""), ErrorCodes.InvalidPayee)
        assert!(shares > 0, ErrorCodes.InvalidShares)
        assert!(sharesMap[account] == 0, ErrorCodes.AccountHasShares)

        // payees.push(account)
        sharesMap[account] = shares
        totalShares = totalShares + shares
        emit PayeeAdded(account, shares)
    }

    //

    @using(updateFields = true, checkExternalCaller = false)
    pub fn release( account: Address) -> () {
        assert!(sharesMap[account] > 0, ErrorCodes.AccountHasNoShares)
        let payment = releasable(account)
        assert!(payment != 0, ErrorCodes.AccountIsNotDuePayment)
        totalReleased = totalReleased + payment
        releasedMap[account] = releasedMap[account] + payment
        // account.transfer(payment)
        emit PaymentReleased(account, payment)
    }


    @using(checkExternalCaller = false)
    pub fn releasable(account: Address)  -> (U256) {
        // let totalReceived = address(this).balance + totalReleased
        let totalReceived = dustAmount!()
        return pendingPayment(account, totalReceived, releasedMap[account])
    }

    pub fn pendingPayment(
        account: Address,
         totalReceived:  U256,
         alreadyReleased:  U256
    ) -> (U256) {
        return (totalReceived * sharesMap[account]) / totalShares - alreadyReleased
    }

    // @using(updateFields = true)
    //  fn addPayeeInt(account: Address,  accountShares:  U256) -> () {
    //     // assert!(account != Address(0), ErrorCodes.InvalidPayee)
    //     assert!(accountShares > 0, ErrorCodes.InvalidShares)
    //     assert!(sharesMap[account] == 0,ErrorCodes.AccountHasShares)
    //     // payees.push(account)
    //     sharesMap[account] = accountShares
    //     totalShares = totalShares + accountShares
    //     emit PayeeAdded(account, accountShares)
    // }
}